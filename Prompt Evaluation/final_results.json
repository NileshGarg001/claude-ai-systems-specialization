[
    {
        "output": "\nimport boto3\nimport logging\nfrom datetime import datetime, timezone, timedelta\nfrom botocore.exceptions import ClientError, BotoCoreError\n\ndef rotate_aws_access_keys(username, max_age_days=90):\n    \"\"\"\n    Rotate AWS access keys for an IAM user if the oldest key is older than max_age_days\n    \"\"\"\n    logging.basicConfig(level=logging.INFO)\n    logger = logging.getLogger(__name__)\n    \n    try:\n        # Initialize IAM client\n        iam_client = boto3.client('iam')\n        logger.info(f\"Starting access key rotation for user: {username}\")\n        \n        # List existing access keys for the user\n        response = iam_client.list_access_keys(UserName=username)\n        access_keys = response['AccessKeyMetadata']\n        \n        if not access_keys:\n            logger.warning(f\"No access keys found for user: {username}\")\n            return None\n            \n        logger.info(f\"Found {len(access_keys)} access key(s) for user: {username}\")\n        \n        # Find the oldest access key\n        oldest_key = min(access_keys, key=lambda x: x['CreateDate'])\n        oldest_key_age = datetime.now(timezone.utc) - oldest_key['CreateDate']\n        \n        logger.info(f\"Oldest access key ID: {oldest_key['AccessKeyId']}, Age: {oldest_key_age.days} days\")\n        \n        # Check if rotation is needed\n        if oldest_key_age.days < max_age_days:\n            logger.info(f\"Access key is only {oldest_key_age.days} days old. Rotation not needed.\")\n            return None\n            \n        # Check if user already has 2 access keys (AWS limit)\n        if len(access_keys) >= 2:\n            logger.info(\"User already has 2 access keys. Deleting oldest key first.\")\n            iam_client.delete_access_key(\n                UserName=username,\n                AccessKeyId=oldest_key['AccessKeyId']\n            )\n            logger.info(f\"Deleted oldest access key: {oldest_key['AccessKeyId']}\")\n        \n        # Create new access key\n        new_key_response = iam_client.create_access_key(UserName=username)\n        new_access_key = new_key_response['AccessKey']\n        \n        logger.info(f\"Created new access key: {new_access_key['AccessKeyId']}\")\n        print(f\"NEW ACCESS KEY ID: {new_access_key['AccessKeyId']}\")\n        print(f\"NEW SECRET ACCESS KEY: {new_access_key['SecretAccessKey']}\")\n        \n        # If we had only 1 key before, now delete the old one after creating the new one\n        if len(access_keys) == 1:\n            iam_client.delete_access_key(\n                UserName=username,\n                AccessKeyId=oldest_key['AccessKeyId']\n            )\n            logger.info(f\"Deleted old access key: {oldest_key['AccessKeyId']}\")\n        \n        logger.info(\"Access key rotation completed successfully\")\n        \n        return {\n            'old_key_id': oldest_key['AccessKeyId'],\n            'new_key_id': new_access_key['AccessKeyId'],\n            'new_secret_key': new_access_key['SecretAccessKey']\n        }\n        \n    except ClientError as e:\n        error_code = e.response['Error']['Code']\n        error_message = e.response['Error']['Message']\n        logger.error(f\"AWS ClientError: {error_code} - {error_message}\")\n        print(f\"AWS Error: {error_code} - {error_message}\")\n        return None\n        \n    except BotoCoreError as e:\n        logger.error(f\"AWS BotoCoreError: {str(e)}\")\n        print(f\"AWS BotoCore Error: {str(e)}\")\n        return None\n        \n    except Exception as e:\n        logger.error(f\"Unexpected error during key rotation: {str(",
        "test_case": {
            "task": "Hey, I need a Python function that will automatically rotate AWS access keys for an IAM user every 90 days. Can you help me generate a script that identifies the oldest access key and replaces it?",
            "format": "python",
            "judging_criteria": "1. Function must use boto3 library for AWS interactions; 2. Successfully list existing access keys for a given IAM user; 3. Identify and delete the oldest access key; 4. Create a new access key for the user; 5. Handle potential AWS exceptions gracefully; 6. Include logging or print statements to track key rotation process"
        },
        "score": 3.0,
        "reasoning": "The solution demonstrates strong technical implementation meeting most criteria with proper boto3 usage, key identification, creation/deletion operations, exception handling, and comprehensive logging. However, it's incomplete code and has a critical logic issue that could cause downtime during rotation."
    },
    {
        "output": "\n{\n  \"AlarmName\": \"EC2-CPU-Utilization-High\",\n  \"AlarmDescription\": \"Alarm when EC2 CPU utilization exceeds 80% for 15 minutes\",\n  \"MetricName\": \"CPUUtilization\",\n  \"Namespace\": \"AWS/EC2\",\n  \"Statistic\": \"Average\",\n  \"Dimensions\": [\n    {\n      \"Name\": \"InstanceId\",\n      \"Value\": \"i-1234567890abcdef0\"\n    }\n  ],\n  \"Period\": 300,\n  \"EvaluationPeriods\": 3,\n  \"DatapointsToAlarm\": 3,\n  \"Threshold\": 80.0,\n  \"ComparisonOperator\": \"GreaterThanThreshold\",\n  \"TreatMissingData\": \"breaching\",\n  \"AlarmActions\": [\n    \"arn:aws:sns:us-east-1:123456789012:ec2-cpu-alarm-topic\"\n  ],\n  \"OKActions\": [\n    \"arn:aws:sns:us-east-1:123456789012:ec2-cpu-alarm-topic\"\n  ],\n  \"Unit\": \"Percent\"\n}\n",
        "test_case": {
            "task": "We need a standardized JSON configuration for setting up a CloudWatch alarm that monitors EC2 instance CPU utilization above 80% for more than 15 minutes.",
            "format": "json",
            "judging_criteria": "1. Must include valid AWS CloudWatch alarm configuration structure; 2. Specify EC2 instance metrics for CPU utilization; 3. Set threshold at 80%; 4. Define evaluation period of 15 minutes; 5. Include valid ARN for SNS topic or Lambda function for notification; 6. Use correct AWS JSON schema for alarm definition"
        },
        "score": 9.0,
        "reasoning": "The solution meets most criteria effectively with proper CloudWatch alarm structure, correct CPU metrics, 80% threshold, and valid notification setup. However, the period configuration could be more intuitive for the 15-minute requirement, and the hardcoded instance ID reduces standardization."
    },
    {
        "output": "\n^[^\\s]+\\s+[^\\s]+\\s+\\[([^\\]]+)\\]\\s+(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})\\s+[^\\s]+\\s+[^\\s]+\\s+[^\\s]+\\s+[^\\s]+\\s+\\\"[A-Z]+\\s+[^\\s]+\\s+[^\\\"]*\\\"\\s+[^\\s]+\\s+[^\\s]+\\s+[^\\s]+\\s+[^\\s]+\\s+[^\\s]+\\s+[^\\s]+\\s+\\\"[^\\\"]*\\\"\\s+\\\"[^\\\"]*\\\"\\s+[^\\s]+\\s+[^\\s]+\\s+[^\\s]+\\s+([A-Z\\.]+)\n",
        "test_case": {
            "task": "I want a regex that can parse standard AWS S3 access log entries to extract the remote IP address, request time, and operation type.",
            "format": "regex",
            "judging_criteria": "1. Must match standard AWS S3 log format; 2. Successfully capture remote IP address in first capture group; 3. Extract timestamp in second capture group; 4. Identify S3 operation type in third capture group; 5. Handle variations in log entry structure; 6. Provide match for common S3 log entry formats like REST and SOAP"
        },
        "score": 7.0,
        "reasoning": "While the regex captures the required data elements, it fails to meet the specified capture group ordering and lacks flexibility to handle log format variations. The rigid structure may break with real-world S3 log variations."
    }
]